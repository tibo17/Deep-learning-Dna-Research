import random
import string


import exrex

import re
import torch
import numpy as np


def sequence_creation_without_pattern(length_sequence, pattern):

    print(" ")
    '''creation of the list which contain all the possibilities of patterns'''
    list_pattern_possibilities = list(exrex.generate(pattern))


    '''Creation of the sequence string'''
    sequence = ''.join(random.choice("ACGT") for i in range(length_sequence))


    '''We initialise pattern already here to True'''
    pattern_already_here = True

    '''This loop stop only when the sequence have no pattern possibility in it'''
    while(pattern_already_here):
        pattern_already_here = False
        for pattern_possibility in list_pattern_possibilities:
            pattern_already_here = re.search(pattern_possibility, sequence)

            if pattern_already_here:
                sequence = ''.join(random.choice("ACGT") for i in range(length_sequence))
                break


    return sequence

sequence_without_pattern = sequence_creation_without_pattern(20, "A[CG]A")



def sequence_creation_with_pattern(length_sequence, pattern):

    '''Creation of a sequence without pattern by calling the function sequence_creation_without_pattern'''
    sequence = sequence_creation_without_pattern(length_sequence, pattern)

    ''' random determination of a fix pattern in the list possibilities'''
    list_pattern_possibilities = list(exrex.generate(pattern))
    nb_pattern_possibilities = len(list_pattern_possibilities)
    position_chosen_pattern = random.randint(0, nb_pattern_possibilities-1)
    chosen_pattern = list_pattern_possibilities[ position_chosen_pattern]
    pattern = chosen_pattern


    ''' determination of a podition for the pattern in the sequence'''
    length_pattern = len(pattern)
    position_pattern = random.randint(0, length_sequence - length_pattern)

    ''' adding of the pattern in the sequence'''
    sequence = sequence[:position_pattern] + pattern + sequence[position_pattern + length_pattern:]


    return sequence

sequence_with_pattern = sequence_creation_with_pattern(20, "A[CG]A")


print(sequence_without_pattern)
print(sequence_with_pattern)



def matrix_creation(sequence):
    ''' this function create a matrix which correspond to the sequence'''
    length_sequence = len(sequence)
    matrix = np.zeros((4, length_sequence))
    for position_lettre in range(length_sequence):

        lettre = sequence[position_lettre]


        if (lettre == "A"):

            matrix[0,position_lettre] = 1

        if (lettre == "C"):

            matrix[1,position_lettre] = 1

        if (lettre == "G"):

            matrix[2,position_lettre] = 1

        if (lettre == "T"):

            matrix[3,position_lettre] = 1

        matrixlist = list(matrix)

        matrixtensor = torch.Tensor(matrixlist)

    return matrixtensor




a = matrix_creation("TGTATTCACGCATCACAAAA")



def dataset_input_creation(pattern, length_sequence, nb_samples):

    ''' this fucntion create a input dataset with half of the data without the pattern, and half of the data with   it'''
    data_input =  []


    for loop in range (nb_samples//2):

        sequence = sequence_creation_without_pattern(length_sequence, pattern)
        matrix = matrix_creation(sequence)

        data_input.append(matrix)

    for loop in range(nb_samples//2):

        sequence = sequence_creation_with_pattern(length_sequence, pattern)
        matrix = matrix_creation(sequence)
        data_input.append(matrix)

    return data_input



def dataset_output_creation(nb_samples):
    ''' this fucntion create a output dataset, half are zeros, half are one '''
    data_output_list =  []

    for loop in range(nb_samples//2):
         data_output_list.append([[0.]])

    for loop in range(nb_samples//2):

        data_output_list.append([[1.]])

    data_output = torch.Tensor(data_output_list)
    return data_output



print(dataset_input_creation("A[CG]A", 20, 10))


print(dataset_output_creation(10))
























